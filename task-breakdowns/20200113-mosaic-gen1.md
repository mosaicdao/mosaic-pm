---
title: "Mosaic Task Breakdown"
disqus: https://hackmd.io/OrizlHecSXKV1-Pi1I5LpQ
---

# Mosaic Task Breakdown

| Version | Last Updated | Component |
| ------- | ------------ | --------- |
| 0.14    | 13/01/2020   | Mosaic Task Breakdown   |

**Meeting date/time:** N/A

**Editor:** Ben|Deepesh|Pro|Abhay|Jayesh|Gulshan

**Team:** N/A

---

# Tasks:

## Coreputation (@abhay)

**Specification:** [Coreputation Specification](https://hackmd.io/bhxONpnpRZOTw3SgYr3TiQ)

**PM document:** [Coreputation PM document](https://github.com/mosaicdao/mosaic-pm/blob/master/specification-discussions/20200108-coreputation.md)

1. Implement Coreputation contract inheritance and storage, enums
1. Implement `Coreputation:upsert(validator, reputation)`
1. Implement `getReputation`
1. Implement `isSlashed` 

## Reputation
**PM document:** https://github.com/mosaicdao/mosaic-pm/blob/master/specification-discussions/20200108-coreputation.md

1. Remove `reputation:slash(...)`

## Utmost (@gulshan)
**PM document:** [Utmost PM document](https://github.com/mosaicdao/mosaic-pm/blob/master/specification-discussions/20200109-utMOST.md)

1. Implement UtilityToken (new: access cogateway over internal fct)
1. Implement `UtilityToken:burn` `UtilityToken:burnFrom`
1. Implement `GenesisUtmost`
1. Implement `Utmost is MasterCopyNonUpgradeble, GenesisUtmost, ERC20, UtilityToken`
1. Implement `Utmost:wrap` and `Utmost:unwrap`
1. Overwrite `UtilityToken:cogateway()` with constant `CONSENSUS_COGATEWAY=0x00..004dxx`

## OriginObserver (@deepesh)
**PM document:** [OriginObserver PM document](https://github.com/mosaicdao/mosaic-pm/blob/master/specification-discussions/20200108-origin-anchor.md)

1. Take existing `Anchor` logic to make a `StateRootProvider is MosaicVersion`
2. Implement `Anchor is MasterCopyNonUpgradable, ConsensusModule, StateRootProvider`
3. Implement `GenesisOriginObserver` it will have `genesisBlockNumber` and `genesisStateRoot`
4. Implement `OriginObserver is MasterCopyNonUpgradable, GenesisOriginObserver, CoconsensusModule, StateRootProvider`
5. Implement `OriginObserver::setup()`
6. Implement `OriginObserver::anchorStateRoot()`

## Coconsensus (@ben, @help)
**PM document:** [Coconsensus PM document](https://github.com/mosaicdao/mosaic-pm/blob/master/specification-discussions/20200108-coconsensus.md)

1. Implement `GenesisCoconsensus`, it has `genesisMetachainIds`
2. Implement `Coconsensus` contract and storage (ie. `blockchains` and others)
3. Implement `Coconsensus::setupObservers() internal`
4. Implement `Coconsensus::setupProtocores() internal`.
5. Implement `domainSeparators` (filled by GenesisCoconsensus)
6. Implement `Coconsensus::setup()`
7. Implement `Coconsensus::finaliseCheckpoint()`
8. Implement `Coconsensus::commitCheckpoint()`
9. Implement `Coconsensus::observeBlock()`
1. Implement `CoconsensusI`

## ValidatorSet
**PM document:** [ValidatorSet PM document](https://github.com/mosaicdao/mosaic-pm/blob/master/specification-discussions/20200114-validatorset.md)

1. Implement `ValidatorSet` contract and storage (`validators`, `validatorBeginHeight`, `validatorEndHeight`)
2. Implement `ValidatorSet::forwardValidatorSetCount()` public
3. Implement `ValidatorSet::insertValidator()` internal
1. Implement `ValidatorSet::removeValidator()` internal
1. Implement `ValidatorSet::inValidatorSet` public
1. Implement `ValidatorSet::inForwardValidatorSet` public
    
## Protocore
**PM document** [Protocore, SelfProtocore and OriginProtocore proposed interfaces](https://hackmd.io/hNL_Co0lQ4Wbn_rpQeCVdQ#Proposed-interfaces).

1. Implement `Protocore` contract and storage (`Links` and others)
1. Implement `Protocore:upsert()` external
3. Implement `Protocore::openMetablock()` 
4. Implement `Protocore::_proposeLink()` internal
5. Implement `Protocore::_registerVote()` internal and emit event `Protocore::VoteRegistered`, `Protocore::LinkUpvoted`
6. Implement `Protocore::hashVoteMessage()` internal
7. Implement `GenesisOriginProtocore`, it has `genesis{LinkParams}`
8. Implement `OriginProtocore::setup()` external
9. Implement `OriginProtocore::proposeLink()` external and emit `OriginProtocore::LinkProposed`
10. Implement `OriginProtocore::registerVote()` external (no inclusion principle)
11. Implement `GenesisSelfProtocore`, it has `genesis{LinkParams}`
12. Implement `SelfProtocore::setup()` external
13. Implement `SelfProtocore::proposeLink()` external  (has inclusion principle) and emit `SelfProtocore::LinkProposed`
**note**: event should carry full Transition params; such that validator can hash; exercise: validator should calculate its own transition objects. when link is proposed and transition objects don't match, validator must not vote for link. Solution: model `Transitions` can have `Status={Broadcast->Calculated}`
1. Implement `SelfProtocore::registerVote()` external

## Core

1. Utilise `ValidatorSet` contract functionality by inheriting from it in Core contract.

1. Add `Core::Created` event:

    ```solidity
    event Created(
        bytes32 domainSeparator,
        bytes32 metachainId,
        uint256 epochLength,
        uint256 minValidator,
        uint256 joinLimit,
        uint256 creationKernelHeight,
        uint256 gasTarget
    )
    ```

## Committee

1. Add `Committee::MemberEntered` event:

    ```solidity
    event MemberEntered{
        bytes32 metachainId,
        bytes32 metablockHash,
        address validator
    }
    ```
    
1. Add `Committee::MemberEjected` event:

    ```solidity
    event MemberEjected{
        bytes32 metachainId,
        bytes32 metablockHash,
        address validator
    }
    ```
    
1. Add `Committee::MemberCommitted` event:
    
    ```solidity
    event MemberCommitted{
        bytes32 metachainId,
        bytes32 metablockHash,
        address validator,
        bytes32 sealedCommit
    }
    ```
    
1. Add `Committee::MemberRevealed` event:

    ```solidity
    event MemberRevealed{
        bytes32 metachainId,
        bytes32 metablockHash,
        address validator,
        bytes32 position
    }
    ```

## Consensus

1. Add `Consensus::formCommittee` event:

    ```solidity
    event CommitteeFormed(
        bytes32 metachainId,
        uint256 formationHeight,
        address committee,
        uint256 committeeSize,
        bytes32 dislocation,
        bytes32 proposal
    )
    ```
    
1. Add `Consensus::ValidatorJoined` event:

    ```solidity 
    event ValidatorJoined(
        bytes32 metachainId,
        address core,
        address validator,
        address withdrawalAddress,
        uint256 validatorBeginHeight,
        uint256 validatorEndHeight,
        uint256 stakedMOSTAmount,
        uint256 stakedWETHAmount,
        uint256 reputation
    )
    ```
    
1. Add `Consensus::MetablockPrecommitted` event:

    ```solidity
    event MetablockPrecommitted{
        bytes32 metachainId,
        address core,
        uint256 precommitHeight,
        bytes32 precommitMetablockHash
    }
    ```

## Axiom

1. Enhance `Axiom::MetachainCreated` event to:

    ```solidity
    event MetachainCreated(
        bytes32 metachainId,
        string mosaicVersion,
        address consensus,
        address anchor,
        address core,
        address consensusGateway
    )
    ```

## ConsensusGateway
1. Implement `ConsensusCogateway:confirmWithdraw()`

## Anchor
1. Refactor the Anchor contract.

## Consensus Cogateway (@deepesh)
1. Implement `ConsensusCogateway:withdraw()`

## Validator: transaction handlers (@pro)

1. [@pro] Implement `Axiom::CreatedMetachain` transaction handler.
    - Updates `Metachain` model.
    - Updates `Anchor` model.
        - `Anchor` model specifies `latestAnchoredBlockNumber` which is not available on anchor creation. Hence, we should either put -1 as a `latestAnchoredBlockNumber` for newly created anchor. Or, specify on `Anchor::setup()` the initial state root and block number.
    - Updates `GenesisFile` model.

1. [@pro] Implement `Core::Created` transaction handler.
    - Updates `Core`  model.

1. [@pro] Implement `Consensus::PublishEndpoint` transaction handler.
    - Updates `PublishedEndpoint` model.

1. [@pro] Implement `Consensus::CommitteeFormed` transaction handler.
    - Updates `Committee` model.
    - Updates `Metablock` model.

1. [@pro] Implement `Consensus::ValidatorJoined` transaction handler.
    - Updates `Validator` model.

1. [@pro] Implement `OriginProtocore::LinkProposed` transaction handler.
    - Updates `Link` model.

1. [@pro] Implement `SelfProtocore::LinkProposed` transaction handler.
    - Updates `Link` model.

1. [@pro] Implement `Protocore::VoteRegistered` transaction handler.
    - Updates `SignedVoteMessages` model.

1. [@pro] Implement `Protocore::LinkJustified` transaction handler.
    - Updates `Link` model.

1. [@pro] Implement `Protocore::LinkFinalized` transaction handler.
    - Updates `Link` model.

1. [@pro] Implement `Core::MetablockProposed` transaction handler.
    - Updates `Metablock` model.

1. [@pro] Implement `Consensus::MetablockPrecommitted` transaction handler.
    - Updates `Metablock` model.

1. [@pro] Implement `Consensus::MetablockCommitteeFormed` transaction handler.
    - Updates `Metablock` model.

1. [@pro] Implement `Consensus::MetablockCommitteeDecided` transaction handler.
    - Updates `Metablock` model.

1. [@pro] Implement `Consensus::MetablockCommitted` transaction handler.
    - Updates `Metablock` model.


1. [@pro] Implement `Anchor::StateRootAvailable` transaction handler:
    - Updates `Anchor` model.

1. [@pro] Implement `Committee::MemberEntered` transaction handler.
    - Updates `Member` model.

1. [@pro] Implement `Committee::MemberEjected` transaction handler.
    - Updates `Member` model.

1. [@pro] Implement `Committee::MemberCommitted` transaction handler.
    - Updates `Member` model.

1. [@pro] Implement `Committee::MemberRevealed` transaction handler.
    - Updates `Member` model.

1. [@pro] Implement `CoConsensus::ProtocoreCreated` transaction handler.
    - Updates `Protocore` model.

    ```solidity
    event ProtocoreCreated{
        bytes32 metachainId,
        address core,
        address protocore,
        uint256 epochLenght,
        uint256 rootHeight,
        uint256 gasTarget,
        bytes32 rootOriginObservation,
        uint256 rootDynasty,
        uint256 rootAccumulatedGas,
        bytes32 rootSourceBlockHash,
        uint256 rootSourceBlockNumber
    }
    ```
    
1. [@pro] Implement `Protocore::MetablockOpened` transaction handler.
    - Updates `Protocore` model.

    ```solidity
    event MetablockOpened {
        uint256 metablockHeight,
        bytes32 kernelHash,
    }
    ```

1. [@abhay] Implement `ConsensusGateway::Deposit` handler
        - Creates entry in DepositIntent model
        - Save DepositRepository
        - Create entry in Message model
        - Save MessageRepository

1. [@abhay] Implement StateRootAvailableHandler
    1. - Saves latest block height in anchor model




## Genesis file generation (@jayesh)
**PM document:** [Genesis file generation PM document](https://github.com/mosaicdao/mosaic-pm/blob/master/specification-discussions/20200108-genesis-file-generation.md)

1. Implement a function `getBytecode` to get the source bytecode for all the contracts.
 
1. Implement function `retrieveGenesisTemplate` to retrieve template of genesis file

1. Implement function `generateGenesis` to generate the genesis file
    ```js
        function generateGeneseis(core: Core) {

        }
    ```
    - From the core model, get the metachain id and write its value for `config.chainId` in genesis file template.
    - Read the timestamp from core model. (discuss this with team about storing the time stamp in the db)
    - Get all the validators address from the db where that joined the core and write its value for `extraData` in genesis file template. (Do we need a flag in validator table about which cores joined before the core openeing ?)
    - Get the deposit amount for all the validators that joined the core using the `validatorDepositIntent` model and write them in the `alloc`. 
    - Get the bytecode of all the contract using the function `getBytecode` and write them in `alloc`
    - Save the generated genesis file to the IPFS and store the CID to the `genesisFiles` model. (Do we need this here or will this be a part of the Validator services?)


## Validator models (@ben @abhay)
**PM document:** [Validator models PM Document](https://github.com/mosaicdao/mosaic-pm/blob/master/specification-discussions/20200114-validator-models.md#modelsrepositories)

1. Implement Metachain model and MetachainRepository
1. Implement Core model and CoreRepository
1. Implement PublishedEndpoint model and PublishedEndpointRepository
1. Implement Genesis model and GenesisRepository
1. Implement Committee model and CommitteeRepository
1. Implement Validator model and ValidatorRepository
1. Implement Link model and LinkRepository
1. Implement Metablock model and MetablockRepository
1. Implement Message model and MessageRepository
1. Implement SignedVoteMessage model and SignedVoteMessageRepository
1. Implement Gateway model and GatewayRepository
1. Implement DepositIntent model and DepositRepository
1. Implement WithdrawIntent model and WithdrawIntentRepository
1. Implement OpenKernelIntent model and OpenKernelIntentRepository
1. Implement Anchor model and AnchorRepository
1. Implement Member model and MemberRepository
1. Implement Protocore model and ProtocoreRepository
1. Implement Kernel model and KernelRepository
1. Implement TransitionObject model and TransitionObjectRepository
1. Implement CoConsensusi model and CoConsensusiRepository
1. Implement ERC20Gateway model and ERC20GatewayRepository
1. Implement AuxiliaryChain model and AuxiliaryChainRepository.
1. <b>TBD</b> - Implement model to store auxiliary chain informations e.g. aux chain rpc endpoints

## Validator services
**PM document:** [Validator PM Document](https://github.com/mosaicdao/mosaic-pm/blob/master/specification-discussions/20200114-validator-models.md#user-stories)

1. Implement Deposit Service 
    - It should call `ConsensusGateway::deposit()` method to stake OST/MOST and WETH tokens for joining the metachain/core.
    
1. Implement JoinBeforeCreation Service 
    - It should call `Core::joinBeforeCreation()` method.
    
1. Implement JoinAfterCreation Service
    - It should call `Core::join()` to join the metachain/core when the core is open or precommitted. 

1. Implement OriginProtocoreProposeLink Service
    - It should call `OriginProtocore::proposeLink()`
    - It should observe the blocks generated on the origin chain so that I can report the origin chain links in the OriginProtocore contract on the auxiliary chain, every epoch length. (source must be justified)

1. Implement SelfProtocoreProposeLink Service
    - It should call `SelfProtocore::proposeLink()`
    - It should observe the blocks generated in the auxiliary chain so that I can report the auxiliary chain links in the SelfProtocore contract on the auxiliary chain, every epoch length. (source must be justified)

1. Implement ProposeMetablock Service
    - It should call `Core::proposeMetablock()`
    - It should be able to propose new metablock in the core contract on the origin chain.

1. Implement RegisterVote Service
    - It should call `Core::registerVote`
    - It should be able to register votes for the new metablock proposals in the core contract 

1. Implement FormCommittee Service
    - It should call `Consensus::formCommittee`
    - It should be able to form a new committee, after the committee formation block height is reached.

1. Implement EnterCommittee Service
    - It should call `Consensus::enterCommittee`
    - Validators should also be able to add other validators also to a committee
    - It will call `AuxiliaryChainManager` library and should be able to start the auxiliary chain node for which the committee was formed, and subscribe to the the mosaic subgraph for this auxiliary chain.
    
    <b>Question:</b> Should AuxiliaryChainManager be a service?

1. Implement AnchorStateRoot Service
    - It anchor the origin state root in the origin anchor (if any are present).

1. Implement ChallengeCommittee Service
    - It should call `Committee::challengeCommittee()` during the committee cool down period

1. Implement ActivateCommittee Service
    - It should call `Committee::activateCommittee()`

1. Implement SubmitSealedCommit Service
    - It should call `Committee::submitSealedCommit()`
    - It should call submit a sealed commit after verifying the auxiliary chain, till the direct (checkpoint) child of the target checkpoint of the votemessage which precommitted the metablock)

1. Implement RevealCommit Service
    - It should call `Committee::revealCommit()`
    - It should be able to reveal position by providing the salt that was used in the sealed commit.

1. Implement Logout Service
    - It should call `Consensus::logout()`



## Validator other tasks(@abhay)

1. Explore Graph database - Gen1 needed?
    - It's needed to maintain relationships between metachain, core, anchor 
    - Below are possible options
        - Neo4j - https://neo4j.com/
        - ArangoDB - https://www.arangodb.com/

1. Define mosaic-subgraph entities
    - https://hackmd.io/CkFgqDFORvac2AiPFTH0Yw#User-stories 
    - Implement events in contracts based on entities

1. Implement mosaic-subgraph 
    - Create new repository
    - Add abis
    - Add schema.graphql
    - Implement subgraph.yml template. Template because contract addresses are dynamic. 
        - Define datasources
        - Define event signatures 
        - Define event handlers
        - Define entities 
    - Deploy subgraph
    - Implement event handlers
    - Call handlers?
    - Block handlers?  

<b>Question:</b> It's more than 3 pointer.

1. Implement Validator config (it's not manifest)
    - Origin chain geth endpoint
    - Other data points? 

1. Populate seed data
    - metachains
    - cores
    - genesis
    - anchor
    - protocores
    - consensusi

1. Implement Subscription libraries
    - It should be able to subscribe to the entities from the graph node.
    - We should create SubscriptionQuery class and define susbcription queries for the different entities
    - Implement GraphClient client library to intract with graph node
    - Implement Subscriber class with below methods
        - Subscribe
        - Unsubscribe

    <b>Question:</b> Move common libraries to new repository
1. Implement starting of validator
    - It does the subscription 
    - Restart subscription after specific interval
     
1. Implement stopping of validator
    - Stops unsubscription
    - Validator executable is gracefully stopped  

1. Implement CalculateMembers method/utility class
    - It should be able to calculate the correct members that should enter the committee. 

1. Implement AuxiliaryChainManager Library
    - Kubernetes for docker process management?
    - When the minimum number of validators join the metachain/core, It should create the genesis file and start the auxiliary chain node. (wait N ethereum blocks)
    - Stop the auxiliary chain after the sealed commit was submitted.
    - Refer [GenesisFileCreation](https://hackmd.io/sz-1wtHdTl6xU7aCwDsAsw)

