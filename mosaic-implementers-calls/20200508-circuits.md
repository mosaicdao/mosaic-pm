# Big Battle of Master versus Circuit

## Master Contract Approach

### Engine


### Master

```solidity
contract Master {

    /* Storage */
    
    address engine;

    mapping(address => address) assignedMapRings;
    mapping(address => address) assignedReduceRings;
    
    bytes32[] resultCIDs;
    
    
    /* External Functions */
    
    constructor(
        address engine,
        bytes32 mapAppDockerCID,
        bytes32 reduceAppDockerCID,
        bytes32[] mapInputCIDs
    ) external;
    
    
    function registerMapResult(bytes32 _resultCID) onlyMapRing external;
    
    function registerReduceResult(bytes32 _resultCID) onlyReduceRing external;
    
    
    /* Internal Functions */
    
    function runMapJob() returns (address assignedMapRing_) internal;
    
    function runReduceJob() returns (address assignedReduceRing_) internal;
}
```


## Circuit approach

### Engine

```solidity
contract Engine {

}

```



### Gate

```solidity
contract Gate {

    struct InternalPin {
        Gate gate;
        uint96 pin;
    }
    
    struct Variable {
        bytes32 cid;
        Ring owner;
    }

    // Input and output pins on gates are represented as uint96
    // because internal pins must reference 20 bytes for an address
    // so the remaining 12 bytes can be used for enumerating the output pins

    // External input pins take in a CID which contains the data from a Ring owner
    // from which the data can be read
    mapping(uint96 => Variable) externalInputs;
    
    // Internal input pins connect to (internal) output legs of a preceding gate.
    // This way we construct dependencies between gates, and a gate is blocked
    // until all (internal) input legs have resolved.
    mapping(uint96 => InternalLeg) internalInputs;
    
    // Output legs can be read by other gates or other components
    mapping(uint96 => bytes32) outputs;
    // Bitmap for which output legs have been computed
    bytes12 outputBitmap;

    uint256 nInternalInputs;
    uint256 nExternalInputs;
    uint256 nInputs;
    uint256 nOutputs;

    constructor(
        bytes32[] _externalInputs,
        InternalLeg[] _internalInputs,
        uint256 _nExternalOutputs,
        uint256 _nInternalOutputs) 
    {
        nExternalInputs = _externalInputs.len();
        nInternalInputs = _internalInputs.len();
        nTotalInputs = nExternalInputs + nInternalInputs;
        
        nExternalOutputs = _nExternalOutputs;
        nInternalOutputs = _nInternalOutputs;
        nTotalOutputs = nExternalOutputs + nInternalOutputs;      
        
// REMARK:
// maybe the legs are better stored in arrays rather than mappings and we can copy this directly
// but Im unsure whether I can have dynamic arrays in storage... ¯\_(ツ)_/¯ 
        for uint i = 0; nExternalInputs; i++ {
            externalInputs[i] = _externalInputs[i];
        }
        for uint i = 0; nInternalInputs.len(); i++ {
            internalInputs[i] = _internalInputs[i] // copy struct correctly
        }
    }
    
    // Write output to 
    function write(bytes32)
    
    
}

```

```solidity
contract MapReduceGate is Gate {
    
    constructor (
        uint256 _nMaps,
        uint256 _nReducers
    ) 
        gate(...)
    {
        
    }
}
```

### Sequence

### Procedural Compiler